<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Tetris Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: black;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid white;
            background: #222;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
        }
        #high-score {
            position: absolute;
            top: 40px;
            right: 10px;
            font-size: 20px;
        }
        #next-block {
            position: absolute;
            top: 60px; /* Positioned below the score */
            right: 10px;
            width: 80px;
            height: 80px;
            border: 2px solid white;
        }
    </style>
</head>
<body>

<canvas width="320" height="640" id="gameCanvas"></canvas>
<div id="score">Score: 0</div>
<div id="high-score">High Score: 0</div>
<div id="next-block">
    <canvas width="80" height="80" id="nextCanvas"></canvas>
</div>
<button id="restart-button" style="position: absolute; top: 100px; right: 10px;">Restart Game</button>

<script>
    const canvas = document.getElementById('gameCanvas');
    const context = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextContext = nextCanvas.getContext('2d');
    const grid = 32;
    let score = 0;
    let highScore = 0;
    let dropIntervall = 1000; // milliseconds
    let gameOver = false;
    
    const tetrominos = [
        { name: 'I', matrix: [[1, 1, 1, 1]] },
        { name: 'O', matrix: [[1, 1], [1, 1]] },
        { name: 'T', matrix: [[0, 1, 0], [1, 1, 1]] },
        { name: 'L', matrix: [[1, 0, 0], [1, 1, 1]] },
        { name: 'J', matrix: [[0, 0, 1], [1, 1, 1]] },
        { name: 'S', matrix: [[0, 1, 1], [1, 1, 0]] },
        { name: 'Z', matrix: [[1, 1, 0], [0, 1, 1]] }
    ];

    let currentTetromino;
    let nextTetromino;
    let currentPosition = { x: 0, y: 0 };

    function getRandomTetromino() {
        return tetrominos[Math.floor(Math.random() * tetrominos.length)];
    }

    function resetGame() {
        score = 0;
        gameOver = false;
        currentTetromino = getRandomTetromino();
        nextTetromino = getRandomTetromino();
        currentPosition = { x: Math.floor(canvas.width / grid / 2) - 1, y: 0 };
        draw();
        document.getElementById('score').innerText = `Score: ${score}`;
        renderNextTetromino();
    }

    function draw() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = '#222';
        context.fillRect(0, 0, canvas.width, canvas.height);
        drawTetromino(currentTetromino, currentPosition);
    }

    function drawTetromino(tetromino, position) {
        context.fillStyle = 'white';
        tetromino.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    context.fillRect((position.x + x) * grid, (position.y + y) * grid, grid - 1, grid - 1);
                }
            });
        });
    }

    function renderNextTetromino() {
        nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
        const matrix = nextTetromino.matrix;
        nextContext.fillStyle = 'white';
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    nextContext.fillRect(x * (grid / 4), y * (grid / 4), (grid / 4) - 1, (grid / 4) - 1);
                }
            });
        });
    }

    function update() {
        if (gameOver) return;
        currentPosition.y++;
        if (collision()) {
            currentPosition.y--;
            placeTetromino();
            currentTetromino = nextTetromino;
            nextTetromino = getRandomTetromino();
            currentPosition = { x: Math.floor(canvas.width / grid / 2) - 1, y: 0 };
            if (collision()) {
                gameOver = true;
                alert('Game Over! Your score: ' + score);
                resetGame();
            }
        }
        draw();
        renderNextTetromino();
    }

    function collision() {
        return currentTetromino.matrix.some((row, y) => {
            return row.some((value, x) => {
                if (value) {
                    const newX = currentPosition.x + x;
                    const newY = currentPosition.y + y;
                    return newX < 0 || newX >= canvas.width / grid || newY >= canvas.height / grid || (newY >= 0 && (context.getImageData(newX * grid, newY * grid, 1, 1).data[0] !== 0));
                }
                return false;
            });
        });
    }

    function placeTetromino() {
        currentTetromino.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    context.fillStyle = 'white';
                    context.fillRect((currentPosition.x + x) * grid, (currentPosition.y + y) * grid, grid - 1, grid - 1);
                }
            });
        });
        score++;
        document.getElementById('score').innerText = `Score: ${score}`;
        if (score > highScore) highScore = score;
        document.getElementById('high-score').innerText = `High Score: ${highScore}`;
    }

    document.getElementById('restart-button').addEventListener('click', resetGame);

    setInterval(update, dropIntervall);
    resetGame();
</script>

</body>
</html>
